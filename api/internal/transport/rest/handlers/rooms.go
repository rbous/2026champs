package handlers

import (
	"2026champs/internal/app"
	"2026champs/internal/model"
	"encoding/json"
	"fmt"
	"math/rand"
	"net/http"
	"time"

	"github.com/gorilla/mux"
)

// GenerateRoomCode generates a random 6-character room code
func GenerateRoomCode() string {
	const charset = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
	rand.Seed(time.Now().UnixNano())
	code := make([]byte, 6)
	for i := range code {
		code[i] = charset[rand.Intn(len(charset))]
	}
	return string(code)
}

// CreateRoomRequest represents the request body for creating a room
type CreateRoomRequest struct {
	HostPlayerID string             `json:"hostPlayerId"`
	Settings     model.RoomSettings `json:"settings"`
}

// CreateRoom godoc
// @Summary Create a new game room
// @Description Creates a new game room with the provided settings
// @Tags rooms
// @Accept json
// @Produce json
// @Param request body CreateRoomRequest true "Room creation request"
// @Success 200 {object} model.Room
// @Failure 400 {string} string "Invalid request body"
// @Failure 500 {string} string "Internal server error"
// @Router /rooms [post]
func CreateRoom(app *app.App) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var req CreateRoomRequest
		if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
			http.Error(w, "Invalid request body", http.StatusBadRequest)
			return
		}

		// Generate unique room code
		roomCode := GenerateRoomCode()

		// Ensure code is unique (simple retry, in production use better approach)
		ctx := r.Context()
		for i := 0; i < 10; i++ {
			existing, _ := app.RoomRepo.GetByCode(ctx, roomCode)
			if existing == nil {
				break
			}
			roomCode = GenerateRoomCode()
		}

		// Set defaults if not provided
		if req.Settings.MaxPlayers == 0 {
			req.Settings.MaxPlayers = 10
		}
		if req.Settings.TimePerQuestionSec == 0 {
			req.Settings.TimePerQuestionSec = 30
		}
		if req.Settings.Mode == "" {
			req.Settings.Mode = "realtime"
		}
		if req.Settings.QuestionSetID == "" {
			req.Settings.QuestionSetID = "default"
		}

		// Create room
		room := &model.Room{
			Code:            roomCode,
			Status:          model.RoomWaiting,
			HostPlayerID:    req.HostPlayerID,
			ActiveSessionID: "",
			Settings:        req.Settings,
			CreatedAt:       time.Now(),
		}

		if err := app.RoomRepo.Create(ctx, room); err != nil {
			http.Error(w, fmt.Sprintf("Failed to create room: %v", err), http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(room)
	}
}

// JoinRoomRequest represents the request body for joining a room
type JoinRoomRequest struct {
	RoomCode   string `json:"roomCode"`
	PlayerName string `json:"playerName"`
}

// JoinRoom godoc
// @Summary Join a room
// @Description Allows a player to join a room
// @Tags rooms
// @Accept json
// @Produce json
// @Param request body JoinRoomRequest true "Join room request"
// @Success 200 {object} model.Player
// @Failure 400 {string} string "Invalid request body or missing fields"
// @Failure 404 {string} string "Room not found"
// @Failure 500 {string} string "Internal server error"
// @Router /rooms/join [post]
func JoinRoom(app *app.App) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var req JoinRoomRequest
		if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
			http.Error(w, "Invalid request body", http.StatusBadRequest)
			return
		}

		if req.RoomCode == "" {
			http.Error(w, "Room code is required", http.StatusBadRequest)
			return
		}
		if req.PlayerName == "" {
			http.Error(w, "Player name is required", http.StatusBadRequest)
			return
		}

		ctx := r.Context()

		// Verify room exists
		room, err := app.RoomRepo.GetByCode(ctx, req.RoomCode)
		if err != nil {
			http.Error(w, fmt.Sprintf("Failed to find room: %v", err), http.StatusInternalServerError)
			return
		}
		if room == nil {
			http.Error(w, "Room not found", http.StatusNotFound)
			return
		}

		// Check if room is full (simplified - would need to count players)
		// For now, we'll allow joining

		// Create player
		player := &model.Player{
			ID:       "", // Will be generated by repo
			RoomCode: req.RoomCode,
			Nickname: req.PlayerName,
			Score:    0,
			Rating:   0,
			JoinedAt: time.Now(),
		}

		if err := app.PlayerRepo.Create(ctx, player); err != nil {
			http.Error(w, fmt.Sprintf("Failed to create player: %v", err), http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(player)
	}
}

// GetRoom godoc
// @Summary Get a room by code
// @Description Retrieves a room by its code
// @Tags rooms
// @Produce json
// @Param code path string true "Room code"
// @Success 200 {object} model.Room
// @Failure 400 {string} string "Room code is required"
// @Failure 404 {string} string "Room not found"
// @Failure 500 {string} string "Internal server error"
// @Router /rooms/{code} [get]
func GetRoom(app *app.App) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		vars := mux.Vars(r)
		code := vars["code"]

		if code == "" {
			http.Error(w, "Room code is required", http.StatusBadRequest)
			return
		}

		ctx := r.Context()
		room, err := app.RoomRepo.GetByCode(ctx, code)
		if err != nil {
			http.Error(w, fmt.Sprintf("Failed to find room: %v", err), http.StatusInternalServerError)
			return
		}
		if room == nil {
			http.Error(w, "Room not found", http.StatusNotFound)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(room)
	}
}
